name: NIDRA Build and Test

on:
  push:
    branches: [ master, development ]
    tags:
      - 'v*'
  pull_request:
    branches: [ master ]

jobs:
  # build-and-test:
  #   permissions:
  #     contents: write
  #   strategy:
  #     fail-fast: false
  #     matrix:
  #       # os: [macos-13, macos-14, macos-15] # Test on Intel and Apple Silicon
  #       # python-version: ['3.9', '3.10', '3.11']
  #       # browser: [chromium, firefox, webkit]
  #       # screen:
  #       #   - { width: 3840, height: 2160 }  # 4K
  #       #   - { width: 2560, height: 1440 }  # 2K
  #       #   - { width: 1920, height: 1080 } # Full HD
  #       #   - { width: 1280, height: 720 }   # HD
  #       #   - { width: 800, height: 600 }    # Small
  #       os: [macos-13, windows-latest]
  #       python-version: ['3.11']
  #       browser: [chromium]
  #       screen:
  #         - { width: 1920, height: 1080 }
  #
  #   runs-on: ${{ matrix.os }}
  #   timeout-minutes: 30
  #
  #   steps:
  #     - name: Check out repository
  #       uses: actions/checkout@v4
  #
  #     - name: Set up Python ${{ matrix.python-version }}
  #       uses: actions/setup-python@v4
  #       with:
  #         python-version: ${{ matrix.python-version }}
  #         cache: 'pip'
  #
  #     - name: Cache Python venv
  #       uses: actions/cache@v4
  #       id: cache-venv
  #       with:
  #         path: venv
  #         key: ${{ runner.os }}-venv-${{ hashFiles('pyproject.toml') }}
  #         restore-keys: |
  #           ${{ runner.os }}-venv-
  #
  #     - name: Setup Python Environment and Install Dependencies (Unix)
  #       if: runner.os != 'Windows' and steps.cache-venv.outputs.cache-hit != 'true'
  #       run: |
  #         python -m venv venv
  #         venv/bin/python -m pip install --upgrade pip setuptools wheel
  #         venv/bin/pip install pyinstaller toml
  #         venv/bin/pip install numpy scipy pandas matplotlib onnxruntime pillow
  #         venv/bin/pip install mne sympy
  #         venv/bin/pip install .
  #
  #     - name: Setup Python Environment and Install Dependencies (Windows)
  #       if: runner.os == 'Windows' and steps.cache-venv.outputs.cache-hit != 'true'
  #       run: |
  #         python -m venv venv
  #         .\venv\Scripts\python.exe -m pip install --upgrade pip setuptools wheel
  #         .\venv\Scripts\pip.exe install pyinstaller toml
  #         .\venv\Scripts\pip.exe install numpy scipy pandas matplotlib onnxruntime pillow
  #         .\venv\Scripts\pip.exe install mne sympy
  #         .\venv\Scripts\pip.exe install .
  #
  #     - name: Cache Hugging Face models and data
  #       uses: actions/cache@v4
  #       id: cache-hf-data
  #       with:
  #         path: |
  #           NIDRA/models
  #           examples/test_data_zmax
  #         key: ${{ runner.os }}-hf-data-v1
  #
  #     - name: Download Models from Hugging Face
  #       if: steps.cache-hf-data.outputs.cache-hit != 'true'
  #       run: |
  #         mkdir -p NIDRA/models
  #         curl -L https://huggingface.co/pzerr/NIDRA_models/resolve/main/ez6.onnx -o NIDRA/models/ez6.onnx
  #         curl -L https://huggingface.co/pzerr/NIDRA_models/resolve/main/ez6moe.onnx -o NIDRA/models/ez6moe.onnx
  #         curl -L https://huggingface.co/pzerr/NIDRA_models/resolve/main/u-sleep-nsrr-2024.onnx -o NIDRA/models/u-sleep-nsrr-2024.onnx
  #         curl -L https://huggingface.co/pzerr/NIDRA_models/resolve/main/u-sleep-nsrr-2024_eeg.onnx -o NIDRA/models/u-sleep-nsrr-2024_eeg.onnx
  #
  #     - name: Download Example Data from Hugging Face
  #       if: steps.cache-hf-data.outputs.cache-hit != 'true'
  #       run: |
  #         mkdir -p examples/test_data_zmax
  #         curl -L https://huggingface.co/pzerr/NIDRA_models/resolve/main/EEG_L.edf -o examples/test_data_zmax/EEG_L.edf
  #         curl -L https://huggingface.co/pzerr/NIDRA_models/resolve/main/EEG_R.edf -o examples/test_data_zmax/EEG_R.edf
  #
  #     - name: Build Executable with PyInstaller (Unix)
  #       if: runner.os != 'Windows'
  #       run: venv/bin/python -m PyInstaller NIDRA.spec
  #
  #     - name: Build Executable with PyInstaller (Windows)
  #       if: runner.os == 'Windows'
  #       run: .\venv\Scripts\python.exe -m PyInstaller NIDRA.spec
  #
  #     - name: Install Test Dependencies (Unix)
  #       if: runner.os != 'Windows'
  #       run: |
  #         venv/bin/pip install playwright requests
  #         venv/bin/python -m playwright install --with-deps ${{ matrix.browser }}
  #
  #     - name: Install Test Dependencies (Windows)
  #       if: runner.os == 'Windows'
  #       run: |
  #         .\venv\Scripts\pip.exe install playwright requests
  #         .\venv\Scripts\python.exe -m playwright install --with-deps ${{ matrix.browser }}
  #
  #     - name: Start Xvfb
  #       if: runner.os == 'macOS'
  #       run: Xvfb :99 -screen 0 1920x1080x24 &
  #
  #     - name: Start app, run demo, take screenshot, and close app
  #       continue-on-error: true
  #       shell: bash
  #       run: |
  #         if [[ "$RUNNER_OS" != "Windows" ]]; then
  #           export DISPLAY=:99
  #         fi
  #         cat <<'EOF' > test_runner.py
  #         import subprocess
  #         import time
  #         import os
  #         import sys
  #         import requests
  #         from playwright.sync_api import sync_playwright
  #
  #         env = os.environ.copy()
  #         env['BROWSER'] = 'echo'
  #
  #         exe_name = 'NIDRA.exe' if sys.platform == 'win32' else 'NIDRA'
  #         exe_path = os.path.abspath(os.path.join('dist', 'NIDRA', exe_name))
  #         print(f"Looking for exe at {exe_path}")
  #
  #         if not os.path.exists(exe_path):
  #             print(f"NIDRA executable not found at {exe_path}. Exiting.")
  #             if os.path.exists('dist/NIDRA'):
  #                 print("Contents of dist/NIDRA:")
  #                 print(os.listdir('dist/NIDRA'))
  #             sys.exit(1)
  #
  #         if sys.platform != 'win32':
  #             print(f"Making executable: {exe_path}")
  #             os.chmod(exe_path, 0o755)
  #
  #         print(f"Starting application from {exe_path}")
  #         proc = subprocess.Popen([exe_path], env=env, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
  #
  #         base_url = "http://127.0.0.1"
  #         ports_to_try =
  #         app_url = None
  #         print("Searching for running server...")
  #         for i in range(30): # Increased wait time
  #             for port in ports_to_try:
  #                 url = f"{base_url}:{port}"
  #                 try:
  #                     response = requests.get(url, timeout=0.5)
  #                     if response.status_code == 200:
  #                         print(f"Server is up and running on {url}")
  #                         app_url = url
  #                         break
  #                 except requests.ConnectionError:
  #                     continue
  #             if app_url:
  #                 break
  #             print(f"Still waiting for server... ({i+1}/30)")
  #             time.sleep(1)
  #
  #         if not app_url:
  #             print("Could not connect to the Flask server on any expected port.")
  #             proc.kill()
  #             stdout, stderr = proc.communicate()
  #             print("--- STDOUT ---")
  #             print(stdout)
  #             print("--- STDERR ---")
  #             print(stderr)
  #             sys.exit(1)
  #
  #         try:
  #             with sync_playwright() as p:
  #                 browser_name = "${{ matrix.browser }}"
  #                 print(f"Launching {browser_name}...")
  #                 browser = getattr(p, browser_name).launch()
  #
  #                 page = browser.new_page(
  #                     viewport={'width': ${{ matrix.screen.width }}, 'height': ${{ matrix.screen.height }}}
  #                 )
  #                 print(f"Navigating to {app_url}")
  #                 page.goto(app_url)
  #                 print("Successfully loaded page.")
  #
  #                 print("Clicking 'Run Demo' button")
  #                 page.click("#show-example-btn")
  #                 time.sleep(15) # Allow time for processing
  #
  #                 print("--- Testing Stability of 'Browse' Buttons ---")
  #
  #                 # Test "Browse" for Input Directory
  #                 print("Clicking 'Browse' for input directory...")
  #                 page.click("#browse-input-btn")
  #                 time.sleep(2) # Wait for backend to process
  #                 # Verify app is still alive by checking the title
  #                 assert "NIDRA" in page.title(), "App crashed after clicking input browse button"
  #                 print("App is stable after input directory browse.")
  #
  #                 # Test "Browse" for Output Directory
  #                 print("Clicking 'Browse' for output directory...")
  #                 page.click("#browse-output-btn")
  #                 time.sleep(2)
  #                 assert "NIDRA" in page.title(), "App crashed after clicking output browse button"
  #                 print("App is stable after output directory browse.")
  #
  #                 # Test "Browse" for File (in .txt mode)
  #                 print("Selecting '.txt file' mode...")
  #                 page.click("#score-from-file")
  #                 time.sleep(1)
  #                 print("Clicking 'Browse' for input file...")
  #                 page.click("#browse-input-btn")
  #                 time.sleep(2)
  #                 assert "NIDRA" in page.title(), "App crashed after clicking input browse button in file mode"
  #                 print("App is stable after input file browse.")
  #
  #                 print("Taking screenshot...")
  #                 screenshot_name = f"screenshot-${{ matrix.os }}-${{ matrix.browser }}-${{ matrix.screen.width }}x${{ matrix.screen.height }}.png"
  #                 page.screenshot(path=screenshot_name, full_page=True)
  #                 print(f"Screenshot saved to {screenshot_name}")
  #                 browser.close()
  #         finally:
  #             print("Terminating application...")
  #             proc.terminate()
  #             try:
  #                 proc.wait(timeout=10)
  #             except subprocess.TimeoutExpired:
  #                 print("Process did not terminate gracefully, killing.")
  #                 proc.kill()
  #             print("Application closed.")
  #         EOF
  #         if [[ "$RUNNER_OS" == "Windows" ]]; then
  #           ./venv/Scripts/python.exe test_runner.py
  #         else
  #           ./venv/bin/python test_runner.py
  #         fi
  #
  #     - name: Upload screenshot
  #       if: always()
  #       uses: actions/upload-artifact@v4
  #       with:
  #         name: screenshot-${{ matrix.os }}-${{ matrix.browser }}-${{ matrix.screen.width }}x${{ matrix.screen.height }}
  #         path: screenshot-${{ matrix.os }}-${{ matrix.browser }}-${{ matrix.screen.width }}x${{ matrix.screen.height }}.png

  gui-test:
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        os: [macos-13, windows-latest]
        python-version: ['3.11']
        browser: [chromium]
        screen:
          - { width: 1920, height: 1080 }

    runs-on: ${{ matrix.os }}
    timeout-minutes: 30

    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip'

      - name: Cache Python venv
        uses: actions/cache@v4
        id: cache-venv
        with:
          path: venv
          key: ${{ runner.os }}-venv-${{ hashFiles('pyproject.toml') }}
          restore-keys: |
            ${{ runner.os }}-venv-

      - name: Setup Python Environment and Install Dependencies (Unix)
        if: runner.os != 'Windows' && steps.cache-venv.outputs.cache-hit != 'true'
        run: |
          python -m venv venv
          venv/bin/python -m pip install --upgrade pip setuptools wheel
          venv/bin/pip install pyinstaller toml
          venv/bin/pip install numpy scipy pandas matplotlib onnxruntime pillow
          venv/bin/pip install mne sympy
          venv/bin/pip install .

      - name: Setup Python Environment and Install Dependencies (Windows)
        if: runner.os == 'Windows' && steps.cache-venv.outputs.cache-hit != 'true'
        run: |
          python -m venv venv
          .\venv\Scripts\python.exe -m pip install --upgrade pip setuptools wheel
          .\venv\Scripts\pip.exe install pyinstaller toml
          .\venv\Scripts\pip.exe install numpy scipy pandas matplotlib onnxruntime pillow
          .\venv\Scripts\pip.exe install mne sympy
          .\venv\Scripts\pip.exe install .

      - name: Cache Hugging Face models and data
        uses: actions/cache@v4
        id: cache-hf-data
        with:
          path: |
            NIDRA/models
            examples/test_data_zmax
          key: ${{ runner.os }}-hf-data-v1

      - name: Download Models from Hugging Face
        if: steps.cache-hf-data.outputs.cache-hit != 'true'
        run: |
          mkdir -p NIDRA/models
          curl -L https://huggingface.co/pzerr/NIDRA_models/resolve/main/ez6.onnx -o NIDRA/models/ez6.onnx
          curl -L https://huggingface.co/pzerr/NIDRA_models/resolve/main/ez6moe.onnx -o NIDRA/models/ez6moe.onnx
          curl -L https://huggingface.co/pzerr/NIDRA_models/resolve/main/u-sleep-nsrr-2024.onnx -o NIDRA/models/u-sleep-nsrr-2024.onnx
          curl -L https://huggingface.co/pzerr/NIDRA_models/resolve/main/u-sleep-nsrr-2024_eeg.onnx -o NIDRA/models/u-sleep-nsrr-2024_eeg.onnx

      - name: Download Example Data from Hugging Face
        if: steps.cache-hf-data.outputs.cache-hit != 'true'
        run: |
          mkdir -p examples/test_data_zmax
          curl -L https://huggingface.co/pzerr/NIDRA_models/resolve/main/EEG_L.edf -o examples/test_data_zmax/EEG_L.edf
          curl -L https://huggingface.co/pzerr/NIDRA_models/resolve/main/EEG_R.edf -o examples/test_data_zmax/EEG_R.edf

      - name: Debugging File and Directory Structure
        run: |
          echo "### DEBUGGING OUTPUT"
          echo "\n--- Current Working Directory ---"
          pwd
          echo "\n--- Full Project Structure ---"
          ls -laR
          echo "\n--- Verifying Key Directories ---"
          ls -R NIDRA/nidra_gui/neutralino || echo "Missing: neutralino"
          ls -R docs || echo "Missing: docs"
          ls -R NIDRA/models || echo "Missing: models"
          ls -R examples || echo "Missing: examples"
          echo "### END DEBUGGING OUTPUT"
      - name: Build Executable with PyInstaller (Unix)
        if: runner.os != 'Windows'
        run: venv/bin/python -m PyInstaller NIDRA.spec

      - name: Build Executable with PyInstaller (Windows)
        if: runner.os == 'Windows'
        run: .\venv\Scripts\python.exe -m PyInstaller NIDRA.spec

      - name: Install Test Dependencies (Unix)
        if: runner.os != 'Windows'
        run: |
          venv/bin/pip install playwright requests
          venv/bin/python -m playwright install --with-deps ${{ matrix.browser }}

      - name: Install Test Dependencies (Windows)
        if: runner.os == 'Windows'
        run: |
          .\venv\Scripts\pip.exe install playwright requests
          .\venv\Scripts\python.exe -m playwright install --with-deps ${{ matrix.browser }}

      - name: Start Xvfb
        if: runner.os == 'macOS'
        run: Xvfb :99 -screen 0 1920x1080x24 &

      - name: Start app, run demo, take screenshot, and close app
        continue-on-error: true
        shell: bash
        run: |
          if [[ "$RUNNER_OS" != "Windows" ]]; then
            export DISPLAY=:99
          fi
          cat <<'EOF' > test_runner.py
          import subprocess
          import time
          import os
          import sys
          import requests
          from playwright.sync_api import sync_playwright

          env = os.environ.copy()
          env['BROWSER'] = 'echo'

          exe_name = 'NIDRA.exe' if sys.platform == 'win32' else 'NIDRA'
          exe_path = os.path.abspath(os.path.join('dist', 'NIDRA', exe_name))
          print(f"Looking for exe at {exe_path}")

          if not os.path.exists(exe_path):
              print(f"NIDRA executable not found at {exe_path}. Exiting.")
              if os.path.exists('dist/NIDRA'):
                  print("Contents of dist/NIDRA:")
                  print(os.listdir('dist/NIDRA'))
              sys.exit(1)

          if sys.platform != 'win32':
              print(f"Making executable: {exe_path}")
              os.chmod(exe_path, 0o755)

          print(f"Starting application from {exe_path}")
          proc = subprocess.Popen([exe_path], env=env, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

          base_url = "http://127.0.0.1"
          ports_to_try =
          app_url = None
          print("Searching for running server...")
          for i in range(30): # Increased wait time
              for port in ports_to_try:
                  url = f"{base_url}:{port}"
                  try:
                      response = requests.get(url, timeout=0.5)
                      if response.status_code == 200:
                          print(f"Server is up and running on {url}")
                          app_url = url
                          break
                  except requests.ConnectionError:
                      continue
              if app_url:
                  break
              print(f"Still waiting for server... ({i+1}/30)")
              time.sleep(1)

          if not app_url:
              print("Could not connect to the Flask server on any expected. Exiting.")
              proc.kill()
              stdout, stderr = proc.communicate()
              print("--- STDOUT ---")
              print(stdout)
              print("--- STDERR ---")
              print(stderr)
              sys.exit(1)

          try:
              with sync_playwright() as p:
                  browser_name = "${{ matrix.browser }}"
                  print(f"Launching {browser_name}...")
                  browser = getattr(p, browser_name).launch()

                  page = browser.new_page(
                      viewport={'width': ${{ matrix.screen.width }}, 'height': ${{ matrix.screen.height }}}
                  )
                  print(f"Navigating to {app_url}")
                  page.goto(app_url)
                  print("Successfully loaded page.")

                  print("Clicking 'Run Demo' button")
                  page.click("#show-example-btn")
                  time.sleep(15) # Allow time for processing

                  print("--- Testing Stability of 'Browse' Buttons ---")

                  # Test "Browse" for Input Directory
                  print("Clicking 'Browse' for input directory...")
                  page.click("#browse-input-btn")
                  time.sleep(2) # Wait for backend to process
                  # Verify app is still alive by checking the title
                  assert "NIDRA" in page.title(), "App crashed after clicking input browse button"
                  print("App is stable after input directory browse.")

                  # Test "Browse" for Output Directory
                  print("Clicking 'Browse' for output directory...")
                  page.click("#browse-output-btn")
                  time.sleep(2)
                  assert "NIDRA" in page.title(), "App crashed after clicking output browse button"
                  print("App is stable after output directory browse.")

                  # Test "Browse" for File (in .txt mode)
                  print("Selecting '.txt file' mode...")
                  page.click("#score-from-file")
                  time.sleep(1)
                  print("Clicking 'Browse' for input file...")
                  page.click("#browse-input-btn")
                  time.sleep(2)
                  assert "NIDRA" in page.title(), "App crashed after clicking input browse button in file mode"
                  print("App is stable after input file browse.")

                  print("Taking screenshot...")
                  screenshot_name = f"screenshot-${{ matrix.os }}-${{ matrix.browser }}-${{ matrix.screen.width }}x${{ matrix.screen.height }}.png"
                  page.screenshot(path=screenshot_name, full_page=True)
                  print(f"Screenshot saved to {screenshot_name}")
                  browser.close()
          finally:
              print("Terminating application...")
              proc.terminate()
              try:
                  proc.wait(timeout=10)
              except subprocess.TimeoutExpired:
                  print("Process did not terminate gracefully, killing.")
                  proc.kill()
              print("Application closed.")
          EOF
          if [[ "$RUNNER_OS" == "Windows" ]]; then
            ./venv/Scripts/python.exe test_runner.py
          else
            ./venv/bin/python test_runner.py
          fi

      - name: Upload screenshot
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: screenshot-${{ matrix.os }}-${{ matrix.browser }}-${{ matrix.screen.width }}x${{ matrix.screen.height }}
          path: screenshot-${{ matrix.os }}-${{ matrix.browser }}-${{ matrix.screen.width }}x${{ matrix.screen.height }}.png

  package-screenshots:
    name: Package All Screenshots
    needs: gui-test
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Download all screenshots
        uses: actions/download-artifact@v4
        with:
          path: screenshots
          pattern: screenshot-*
          merge-multiple: true

      - name: Upload screenshots as single artifact
        uses: actions/upload-artifact@v4
        with:
          name: screenshots
          path: screenshots/*
